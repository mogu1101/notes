# 启动优化
## 冷启动
### 编译链接过程
* 程序中编写的代码文件（如：.h .m .cpp .swift）会被转成 mach-o 文件
* 预编译：宏定义展开
* 编译：词法分析、语法分析
* 汇编：翻译成机器指令
* 链接：
  * 静态链接
    * 静态链接库
      * .o文件集合
      * 头文件集合
      * 资源文件集合
  * 动态链接
    * 动态链接库：已经链接完成的镜像
  * 静态库和动态库的区别
    * 静态库没有被链接过
    * 动态库已经被静态链接过，等待动态链接
  * 静态库和动态库的优劣
    * 静态库：产物体积较大，链接到App后App体积会比较小
    * 动态库：产物体积较小，链接到App后App体积会比较大

### dyld 加载流程

[参考文章](https://juejin.cn/post/6844904040149729294)

`dyld` 全名 `The dynamic link editor` ，是苹果的动态链接器，在应用被编译打包成可执行的 `Mach-O` 文件之后，交由 `dyld` 负责链接，加载程序。

`ASLR` 地址空间配置随机加载，即使用一个随机值来实现地址空间配置随机分配，可以使某些攻击者无法事先获知地址，令攻击者难以通过固定地址获取函数或者内存值进行攻击

* dyldbootstrap :: start
  * 根据计算出来的 `ASLR` 的 `slide` 来重定向 `Mach-O`
  * 初始化，允许 `dyld` 使用 mach 消息传递
  * 栈溢出保护
  * 初始化完成后调用 `dyld::main`
* dyld::main
  * 准备工作
    * 配置相关环境变量
    * 设置上下文信息 `setContext`
    * 检测进程是否受限，在上下文中做出对应处理 `configureProgressRestrictions` ，检查环境变量 `checkEnvironmentVariables`
    * 根据环境变量配置打印信息， `DYLD_PRINT_OPTS` 与 `DYLD_PRINT_ENV` 
  
  
      ![dyldPrint](../../images/dyldPrint.awebp)
  
    * 获取程序架构 `getHostInfo`
  * 加载共享缓存库
    * 检测共享缓存禁用状态 `checkSharedRegionDisable` （iOS下不会被禁用）
    * 加载共享缓存库，`mapSharedCache` -> `loadDyldCache`，这里加载共享缓存有几种情况：
      * 仅加载到当前进程 `mapCachePrivate` ，（模拟器仅支持加载到当前进程）
      * 共享缓存是第一次被加载，执行加载操作 `mapCacheSystemWide`
      * 共享缓存不是第一次被加载，不做任何操作
  * reloadAllImages
    * 实例化主程序, 检测可执行程序格式
    * `isCompatibleMachO` 里就会通过 `header` 里的 `magic` ，`cputype` ， `cpusubtype` 去检测是否兼容
    * 检测通过， 就会通过 `instantiateMainExecutable` 实例化这个 `image` ，并添加到 `static std::vector<ImageLoader*> sAllImages;` 这个全局的镜像列表中去，设置好上下文
    * 
  * 加载插入动态库
    * 根据 `DYLD_INSERT_LIBRARIES` 环境变量来决定是否需要加载插入的动态库 
  * 链接主程序
    * `recursiveLoadLibraries`
    * `recursiveBindWithAccounting -> recursiveBind` 符号绑定
    * `link` 函数执行完毕之后 , `dyld::main` 会调用 `sMainExecutable->weakBind(gLinkContext);` 进行弱绑定, 懒加载绑定, 也就是说弱绑定一定发生在其他库链接绑定完成之后 
* 运行主程序
  * `initializeMainExecutable` -> `runInitializers` -> `processInitializers` -> 递归调用 `recursiveInitialization`
  * 调用 `notifySingle` 函数
    * 该函数会执行一个回调
    * 该回调是 `_objc_init` 初始化的时候赋值的一个函数 `load_images`
      * `load_images` 里面执行了 `call_load_methods` 函数
        * `call_load_methods` 函数循环调用各个类的 `load` 方法
  * `doModInitFunctions` 函数
    * 内部会调用带 `__attribute__((constructor))` 的C函数
  * 返回主程序入口函数，开始进入主程序的 `main` 函数

[dyld加载过程](https://juejin.cn/post/6844904040149729294)

### pre-main
* 加载 `dyld` 和可执行文件
* `dyld` 加载可执行文件中依赖的动态库
* 可执行文件和动态库加载到内存中地址不固定，需要进行 `rebase` 和 `binding` 操作，指向正确地址
* `runtime` 注册OC类、注册 `Category` 方法，`Selector` 唯一性检测，调用 `load` 方法，调用 C++ 构造函数
* `DYLD_PRINT_STATISTICS` 用来检测 `pre-main` 时间

* 优化
  * 慎用 `load` 方法
  * 减少类的数量，删除没有用的方法（使用 fui 查找未使用的类）
  * 合并或减少动态库
  * 二进制重拍